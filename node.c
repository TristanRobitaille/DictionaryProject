#include "node.h"

struct dictNode *createNode(struct dictNode *parentPtr){
	/*! Allocates memory for a new node, passes in the address to the parent node in the BST and initializes balance factor at 0.
	 * Returns NULL is allocation is unsuccessful, or pointer to new node is successful.
	 */

	struct dictNode *newNode = malloc(sizeof(struct dictNode)); //Allocate memory for the node to be initialized

	if (newNode == NULL){
		printf("Initialization of a new node has failed (malloc returned NULL).\n");
		return NULL;
	}

	newNode->parent = parentPtr; //Pass in the value of the node's parent
	newNode->balanceFactor = 0; //Initialize balance factor at 0
	return newNode;
};

int deleteNode(struct dictNode *toBeDeleted){
	/*! Frees memory used by the node toBeDeleted
	 * Returns 1 if deletion was successful
	 */

	free(toBeDeleted);

	return 1;
}

struct dictNode *insertNode(struct dictNode *tobeInserted, struct linkedDict *dict){
	/*!The function takes the precreated node that is going to be inserted to the tree,
	 * also the correct tree in the linked list, which needs to be generated by another function
	 * The function returns the new root of the AVL tree or no return but update the root of the tree directly
	 */

	//if the inserting node is empty
	if (tobeInserted == NULL){
		return NULL;
	}

	//if the inserting node is not empty
	else{
		//check if the dictionary is empty
		if(dict->root == NULL){
			dict->root = tobeInserted;
		}

		else{
			//check word ascii value
			if((tobeInserted->word) < (dict->root->word)){
				tobeInserted = insert(tobeInserted, dict->root->leftChild);
			}
			else if((tobeInserted->word) > (dict->root->word)){
				tobeInserted =  insert(tobeInserted, dict->root->leftChild);
			}

			//if the word already exists in the dict
			else if((tobeInserted->word) == (dict->root->word)){
				int originaldef = sizeof(dict->root->def);//original def size, unsure to use strlen or sizeof
				dict->root->def = realloc(dict->root->def, (originaldef + sizeof(tobeInserted->def)) * sizeof(char));//sizeof or strlen?
				dict->root->def + originaldef = tobeInserted->def;
				int a = deleteNode(tobeInserted);//no need to assign a value if the function is changed to void
				break;//not sure whether we need it
			}

			/*!update balance factor
			 *rotate
			 */
			balanceTree(dict->root);
		}
	}
}

struct dictNode *insert(struct dictNode *tobeInserted, struct dictNode *subroot){
	/*!The recursive function takes the node going to be inserted, and the subroot of the tree
	 *The subroot is being recursively changed
	 *Undetermined return
	 */
	if(subroot == NULL){
		subroot = tobeInserted;
	}

	else{
		//check word ascii value
		if((tobeInserted->word) < (subroot->word)){
			return insert(tobeInserted, subroot->leftChild);
		}
		else if((tobeInserted->word) > (subroot->word)){
			return insert(tobeInserted, subroot->leftChild);
		}

		//if the word already exists in the dict
		else if((tobeInserted->word) == (subroot->word)){
			char *start = subroot->def;
			int originaldef = sizeof(subroot->def);//or strlen, unsure
			subroot->def = realloc(subroot->def, (originaldef + sizeof(tobeInserted->def)) * sizeof(char));//sizeof or strlen?
			subroot->def + originaldef = tobeInserted->def;
			int a = deleteNode(tobeInserted);//no need to assign a value if the function is changed to void
			break;//not sure whether we need it
		}
	}
	return tobeInserted;
}

int getHeight(struct dictNode *node){
	if (node == NULL){
		return 0;
	}
	return node->height;
}
int getBalance(struct dictNode *node){
	if(node){
		return 0;
	}
	return getHeight(node->left) - getHeight(node->right);
}


struct dictNode *rightRotate(struct dictNode *node){
	/*!right rotate at node
	 * update height
	 * return the new subroot
	 */

	struct dictNode *leftnode = node->leftChild;
	struct dictNode *temp = leftnode->rightChild;

	leftnode->rightChild = node;
	node->leftChild = temp;

	node->height = max(height(node->leftChild));
	leftnode->height = max(height(leftnode->leftChild));

	return leftnode;
}

struct dictNode *leftRotate(struct dictNode *node){
	/*!left rotate at node
	 * update height
	 * return the new subroot
	 */

	struct dictNode *rightnode = node->rightChild;
	struct dictNode *temp = rightnode->leftChild;

	rightnode->leftChild = node;
	node->rightChild = temp;

	node->height = max(height(node->leftChild));
	rightnode->height = max(height(rightnode->leftChild));

	return rightnode;
}

void balanceTree(struct dictNode *node){
	int balance = getBalance(node);

	//four cases
}



