/*
 * dict.c
 *
 *  Created on: Apr 6, 2020
 *      Author: wtyte
 */
#include "dict.h"
#include <string.h>
#include <math.h>



struct linkedDict** createDict(){
	struct linkedDict **dict = calloc(26, sizeof(struct linkedDict *));

	for(int i=0; i<26; i++){
		dict[i] = malloc(sizeof(struct linkedDict));
		dict[i]->name = malloc(sizeof(char));
		*(dict[i]->name) = (char)(i+65);
		dict[i]->root = NULL;
		dict[i]->size = 0;
	}

	return dict;
}

struct dictNode *insertNode(struct dictNode *tobeInserted, struct linkedDict *dict){
	/*!The function takes the precreated node that is going to be inserted to the tree,
	 * also the correct tree in the linked list, which needs to be generated by another function
	 * The function returns the new root of the AVL tree or no return but update the root of the tree directly
	 */

	//if the inserting node is empty
	//struct dictNode* r = malloc(sizeof(struct dictNode));
	if (tobeInserted == NULL){
		return NULL;
	}

	//if the inserting node is not empty
	else{
		//check if the dictionary is empty
		if(dict->root == NULL){
			dict->root = tobeInserted;
		}

		else{
			//check word ascii value
			if(strcmp((tobeInserted->word), (dict->root->word)) < 0){
				dict->root->leftChild = insert(tobeInserted, dict->root->leftChild);
			}
			else if(strcmp((tobeInserted->word), (dict->root->word)) > 0){
				dict->root->rightChild =  insert(tobeInserted, dict->root->rightChild);
			}

			//This is can be written as a separate function void append(struct dictNode *tobeInserted, sturct dictNode *subroot)
			//if the word already exists in the dict
			else if(strcmp((tobeInserted->word), (dict->root->word)) == 0){
				//static char *start = dict->root->def;
				//int originaldef = sizeof(dict->root->def); //original def size, unsure to use strlen or sizeof
				//dict->root->def = realloc(dict->root->def, (originaldef + sizeof(tobeInserted->def)) * sizeof(char));//sizeof or strlen?
				//dict->root->def = dict->root->def + originaldef;
				strcat(dict->root->def, tobeInserted->def); //update def
				//free(tobeInserted);//no need to assign a value if the function is changed to void
			}
			dict->root = balanceTree(dict->root, tobeInserted);
		}
	}
	dict->size = dict->size + 1;
	//r = dict->root;
	printf("it returned: %s\n", dict->root->word);
	return dict->root;
}


struct dictNode *deleteNode(struct dictNode *tobeDeleted, struct linkedDict *dict){
	/*! Frees memory used by the node toBeDeleted
	 * Returns the new root after deletion
	 */
	if(tobeDeleted == NULL){
		return NULL;
	}

	else{
		//check if the dictionary is empty
		if(dict->root == NULL){
			dict->root = NULL;
		}

		else{
			//check word ascii value
			if(strcmp((tobeDeleted->word), (dict->root->word)) < 0){
				dict->root->leftChild = delete(tobeDeleted, dict->root->leftChild);
			}
			else if(strcmp((tobeDeleted->word), (dict->root->word)) > 0){
				dict->root->rightChild =  delete(tobeDeleted, dict->root->rightChild);
			}
			else{
				//one child case
				if((dict->root->leftChild == NULL) || (dict->root->rightChild == NULL)){
				   struct dictNode *temp = dict->root->leftChild ? dict->root->leftChild : dict->root->rightChild;

					// No child case
					if (temp == NULL)
					{
						temp = dict->root;
						dict->root = NULL;
					}
					else // One child case
					 *(dict->root) = *temp; // Copy the contents of
									// the non-empty child
					free(temp);
				}
				//two child case
				else{
					// Get the inorder successor (smallest in the right subtree)
					printf("root right: %s\n", dict->root->rightChild->word);

					printf("here\n");
					struct dictNode* temp = minValueNode(dict->root->rightChild);
					struct dictNode* leftbranch = dict->root->leftChild;
					struct dictNode* rightbranch = dict->root->rightChild;
					printf("root right: %s\n", dict->root->rightChild->word);

					// Copy the inorder successor's data to this node
					*(dict->root) = *temp;

					//retain its original leftbranch
					dict->root->leftChild = leftbranch;
					dict->root->rightChild = rightbranch;

					// Delete the inorder successor
					dict->root->rightChild = delete(dict->root->rightChild, temp);

					printf("out?");
					free(leftbranch);
					//free(temp); not sure whether to free it here
				}
			}
		}
	}

	dict->size = dict->size - 1;
	return dict->root;
}



int findDict(struct dictNode* target){
	//need to convert all word to uppercase when making the node
	return ((int)*(target->word) - 65);
}

int getSize(struct linkedDict* dict){
	return dict->size;
}

char* getAuthor(struct linkedDict* dict){
	return dict->author;
}

char* getDef(struct dictNode* target, struct linkedDict** dict){
	int c = findDict(target);

	if(strcmp(target->word, dict[c]->root->word) == 0){
		return dict[c]->root->def;
	}
	else if(strcmp(target->word, dict[c]->root->word) < 0){
		return getDef_Helper(target, dict[c]->root->leftChild);
	}
	else if(strcmp(target->word, dict[c]->root->word) > 0){
		return getDef_Helper(target, dict[c]->root->rightChild);
	}

	printf("%s not found in dict.\n", target->word);
	return NULL;
}

char* getDef_Helper(struct dictNode* target, struct dictNode* subroot){
	if(strcmp(target->word, subroot->word) == 0){
		return subroot->def;
	}
	else if(strcmp(target->word, subroot->word) < 0){
		return getDef_Helper(target, subroot->leftChild);
	}
	else if(strcmp(target->word, subroot->word) > 0){
		return getDef_Helper(target, subroot->rightChild);
	}

	printf("%s not found in dict.\n", target->word);
	return NULL;
}

/*
struct linkedDict* loadTree_fromFile(char* filename){
	FILE *fptr = fopen(filename, "r");

	fclose(fptr);
}*/



