/*
 * dict.c
 *
 *  Created on: Apr 6, 2020
 *      Author: wtyte
 */
#include "dict.h"
#include <string.h>
#include <math.h>
#include <ctype.h>



struct linkedDict** createDict(){
	struct linkedDict **dict = calloc(26, sizeof(struct linkedDict *));

	for(int i = 0; i < 26; i++){
		dict[i] = malloc(sizeof(struct linkedDict));
		dict[i]->name = malloc(sizeof(char));
		*(dict[i]->name) = (char)(i+65);
		dict[i]->root = NULL;
		dict[i]->size = 0;
	}

	return dict;
}

struct dictNode *insertNode(struct dictNode *tobeInserted, struct linkedDict *dict){
	/*!The function takes the precreated node that is going to be inserted to the tree,
	 * also the correct tree in the linked list, which needs to be generated by another function
	 * The function returns the new root of the AVL tree or no return but update the root of the tree directly
	 */

	//if the inserting node is empty
	//struct dictNode* r = malloc(sizeof(struct dictNode));
	if (tobeInserted == NULL){
		return NULL;
	}

	//if the inserting node is not empty
	else{
		//check if the dictionary is empty
		if(dict->root == NULL){
			dict->root = tobeInserted;
		}

		else{
			//check word ascii value
			if(strcmp((tobeInserted->word), (dict->root->word)) < 0){
				dict->root->leftChild = insert(tobeInserted, dict->root->leftChild);
			}
			else if(strcmp((tobeInserted->word), (dict->root->word)) > 0){
				dict->root->rightChild =  insert(tobeInserted, dict->root->rightChild);
			}

			dict->root = balanceTree(dict->root, tobeInserted);
		}
	}
	dict->size = dict->size + 1;
	//r = dict->root;
//	printf("it returned: %s\n", dict->root->word);
	return dict->root;
}


struct dictNode *deleteNode(struct dictNode *tobeDeleted, struct linkedDict *dict){
	/*! Frees memory used by the node toBeDeleted
	 * Returns the new root after deletion
	 */
	if(tobeDeleted == NULL){
		return NULL;
	}

	else{
		//check if the dictionary is empty
		if(dict->root == NULL){
			dict->root = NULL;
		}

		else{
			//check word ascii value
			if(strcmp((tobeDeleted->word), (dict->root->word)) < 0){
				dict->root->leftChild = delete(tobeDeleted, dict->root->leftChild);
			}
			else if(strcmp((tobeDeleted->word), (dict->root->word)) > 0){
				dict->root->rightChild =  delete(tobeDeleted, dict->root->rightChild);
			}
			else{
				//one child case
				if((dict->root->leftChild == NULL) || (dict->root->rightChild == NULL)){
				   struct dictNode *temp = dict->root->leftChild ? dict->root->leftChild : dict->root->rightChild;

					// No child case
					if (temp == NULL)
					{
						temp = dict->root;
						dict->root = NULL;
					}
					else // One child case
					 *(dict->root) = *temp; // Copy the contents of
									// the non-empty child
					free(temp);
				}
				//two child case
				else{
					// Get the inorder successor (smallest in the right subtree)
//					printf("root right: %s\n", dict->root->rightChild->word);

//					printf("here\n");
					struct dictNode* temp = minValueNode(dict->root->rightChild);
					struct dictNode* leftbranch = dict->root->leftChild;
					struct dictNode* rightbranch = dict->root->rightChild;
//					printf("root right: %s\n", dict->root->rightChild->word);

					// Copy the inorder successor's data to this node
					*(dict->root) = *temp;

					//retain its original leftbranch
					dict->root->leftChild = leftbranch;
					dict->root->rightChild = rightbranch;

					// Delete the inorder successor
					dict->root->rightChild = delete(dict->root->rightChild, temp);

//					printf("out?");
					free(leftbranch);
					//free(temp); not sure whether to free it here
				}
			}
		}
	}

	dict->size = dict->size - 1;
	return dict->root;
}


int findDict(struct dictNode* target){
	//need to convert all word to uppercase when making the node
	return toupper(target->word[0]) - 65;
}

int getSize(struct linkedDict* dict){
	return dict->size;
}

char* getAuthor(struct linkedDict* dict){
	return dict->author;
}

char* getDef(struct dictNode* target, struct linkedDict** dict){
	int c = findDict(target);

	if(strcmp(target->word, dict[c]->root->word) == 0){
		return dict[c]->root->def;
	}
	else if(strcmp(target->word, dict[c]->root->word) < 0){
		return getDef_Helper(target, dict[c]->root->leftChild);
	}
	else if(strcmp(target->word, dict[c]->root->word) > 0){
		return getDef_Helper(target, dict[c]->root->rightChild);
	}

//	printf("%s not found in dict.\n", target->word);
	return NULL;
}

char* getDef_Helper(struct dictNode* target, struct dictNode* subroot){
	if(strcmp(target->word, subroot->word) == 0){
		return subroot->def;
	}
	else if(strcmp(target->word, subroot->word) < 0){
		return getDef_Helper(target, subroot->leftChild);
	}
	else if(strcmp(target->word, subroot->word) > 0){
		return getDef_Helper(target, subroot->rightChild);
	}

//	printf("%s not found in dict.\n", target->word);
	return NULL;
}

int levenshtein(const char *strA, int lenA, const char *strB, int lenB){
	int a, b, c;

	//If strings are empty, distance is num of characters of the other
	if (!lenA) return lenB;
	if (!lenB) return lenA;

	//If last letters are the same, the difference is whatever is required to edit the rest of the strings
	if (strA[lenA - 1] == strB[lenB - 1]) return levenshtein(strA, lenA - 1, strB, lenB - 1);

	/*If last letters are not the same, try:
	 *	changing last letter of s to that of t; or
	 *  remove last letter of s; or
	 *  remove last letter of t,
	 * any of which is 1 edit plus editing the rest of the strings
	 */
	a = levenshtein(strA, lenA - 1, strB, lenB - 1);
	b = levenshtein(strA, lenA, strB, lenB - 1);
	c = levenshtein(strA, lenA - 1, strB, lenB);

	if (a > b) a = b;
	if (a > c) a = c;

	return a + 1;
}

struct linkedDict** loadTree_fromFile(char* filename, struct linkedDict** dict){
	FILE *fptr = fopen(filename, "r");

	char line[10000];
	struct dictNode *prevNode = NULL;

	while(fgets(line, sizeof(line), fptr) != NULL) { //Read every line until empty
	    char *token, *word, *definition;
	    if (line[0] == '"') line[0] = ' ';

		token = strtok(line, " "); //Extract word
		word = token;

		token = strtok(NULL, ")"); //Extract definition
		token = strtok(NULL, "");
		definition = token;
		word[strcspn(word, "\n")] = 0; //Remove newline character
		definition[strcspn(definition, "\n")] = 0; //Remove newline character

		struct dictNode *newNode = createNode(word, definition);
		if (prevNode != NULL) prevNode->nextWord = newNode;
		newNode->previousWord = prevNode;
		prevNode = newNode;
		insertNode(newNode, dict[0]);
//		printf("Inserted: %s\n", newNode->word);
		fgets(line, sizeof(line), fptr);
		struct dictNode *prevNode = newNode;
	}

	fclose(fptr);
	return dict;
}

//struct linkedDict** loadTree_fromFile(char* filename, struct linkedDict** dict){
//	FILE *fptr = fopen(filename, "r");
//
//	//struct linkedDict **dict = calloc(26, sizeof(struct linkedDict*));
//    char *Array[10000000][10000000];
//    char line[10000];
//    char *w;
//    char *d;
//    char *exit;
//    int i, j;
//
//    i = 0;
//    while(fgets(line, sizeof(line), fptr))
//    {
//        j = 0;
//        w = strtok(line, "(");  // initialize line tokens
//        if(w){  // won't enter if the line is empty, and stops when no more tokens
//            Array[i][j] = strdup(w);
//            //printf("printword: %s", Array[i][j]);
//            j = j + strlen(w);
//            d = strtok(NULL, "(");  // next token
//            Array[i][j] = strdup(d);
//            exit = strtok(NULL, "(");
//            fgets(line, sizeof(line), fptr);
//        }
//        printf("\n");
//        i++;
//    }
//
//    int count = i;
//    i = j = 0;
//	int c = (int)*w - 65;
//
//	while(i < count){
//		struct dictNode *temp;
//		w = Array[i][j];
//		d = Array[i][j + strlen(w)];
//
//		if(i < 1){
//			temp = createNode_fromFile(w, d, NULL, NULL);
//			dict[c]->root = insertNode(temp, dict[c]);
//			printf("dict[c] root: %s\n", dict[c]->root->word);
//			//printf("Then\n");
//		}
//		else{
//			//printf("here\n");
//			j = 0;
//			char *pword = Array[i-1][j];
//			printf("pword: %s\n", pword);
//			char *nword = Array[i+1][j];
//			printf("nword: %s\n", nword);
//
//			//printf("here?\n");
//			struct dictNode* pw = NULL;
//			struct dictNode* nw = NULL;
//			printf("dict[c] root: %s\n", dict[c]->root->word);
//
//			if (pword){
//				pw = returnNode(dict[c]->root, pword);
//			}
//			if (nword){
//				nw = returnNode(dict[c]->root, nword);
//			}
//			//printf("here??\n");
//			temp = createNode_fromFile(w, d, pw, nw);
//			//printf("here???\n");
//			dict[c]->root = insertNode(temp, dict[c]);
//		}
//		i++;
//		j = 0;
//	}
//	fclose(fptr);
//
//	return dict;
//}


char* scroll(struct linkedDict* dict, char* target, char* direction){
	struct dictNode *node = returnNode(dict->root, target);

	if(strcmp(direction, "up") == 0) return node->previousWord->word;
	else if(strcmp(direction, "down") == 0) return node->nextWord->word;
	return target;
}

void dummyLoad(struct linkedDict **dict){
	char w[] = "Cable\0";
	char d[] = "A rope of steel wire, or copper wire, usually covered with some protecting or insulating substance; as, the cable of a suspension bridge; a telegraphic cable.";
	struct dictNode *n = createNode(w,d);
	n->previousWord = NULL;

	//create node terry
	char w2[] = "Cabled\0";
	char d2[] = "Fastened with, or attached to, a cable or rope.";
	struct dictNode *m = createNode(w2, d2);
	m->previousWord = n;
	n->nextWord = m;

	//create node tina
	char w3[] = "Cablegram\0";
	char d3[] = "A message sent by a submarine telegraphic cable.";
	struct dictNode *k = createNode(w3, d3);
	k->previousWord = m;
	m->nextWord = k;

	//create node tina
	char w4[] = "Cablelaid\0";
	char d4[] = "Composed of three three-stranded ropes, or hawsers, twisted together to form a cable.";
	struct dictNode *l = createNode(w4, d4);
	l->previousWord = k;
	k->nextWord = l;

	//create node tina
	char w5[] = "Cablet\0";
	char d5[] = "A little cable less than ten inches in circumference.";
	struct dictNode *p = createNode(w5, d5);
	p->previousWord = l;
	l->nextWord = p;

	//create node tina
	char w6[] = "Cabling\0";
	char d6[] = "The decoration of a fluted shaft of a column or of a pilaster with reeds, or rounded moldings, which seem to be laid in the hollows of the fluting. These are limited in length to about one third of the height of the shaft.";
	struct dictNode *a = createNode(w6, d6);
	a->previousWord = p;
	p->nextWord = a;

	//create node tina
	char w7[] = "Cabmen\0";
	char d7[] = "Plural of cabman.";
	struct dictNode *b = createNode(w7, d7);
	b->previousWord = a;
	a->nextWord = b;

	//create node tina
	char w8[] = "Cabman\0";
	char d8[] = "The driver of a cab.";
	struct dictNode *c = createNode(w8, d8);
	c->previousWord = b;
	b->nextWord = c;

	//create node tina
	char w9[] = "Cabob\0";
	char d9[] = "A small piece of mutton or other meat roasted on a skewer; -- so called in Turkey and Persia.";
	struct dictNode *f = createNode(w9, d9);
	f->previousWord = c;
	c->nextWord = f;

	//create node tina
	char w10[] = "Caboched\0";
	char d10[] = "Showing the full face, but nothing of the neck; -- said of the head of a beast in armorial bearing.";
	struct dictNode *e = createNode(w10, d10);
	e->previousWord = f;
	p->nextWord = NULL;

	//find tree index
	int qw = findDict(n);

	//insert nodes
	dict[qw]->root = insertNode(n, dict[qw]);
	dict[qw]->root = insertNode(m, dict[qw]);
	dict[qw]->root = insertNode(k, dict[qw]);
	dict[qw]->root = insertNode(l, dict[qw]);
	dict[qw]->root = insertNode(p, dict[qw]);
	dict[qw]->root = insertNode(a, dict[qw]);
	dict[qw]->root = insertNode(b, dict[qw]);
	dict[qw]->root = insertNode(c, dict[qw]);
	dict[qw]->root = insertNode(f, dict[qw]);
	dict[qw]->root = insertNode(e, dict[qw]);
}

