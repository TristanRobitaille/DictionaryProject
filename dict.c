/*
 * dict.c
 *
 *  Created on: Apr 6, 2020
 *      Author: wtyte
 */
#include "dict.h"
#include <string.h>
#include <math.h>
#include <ctype.h>



struct linkedDict** createDict(){
	struct linkedDict **dict = calloc(26, sizeof(struct linkedDict *));

	for(int i = 0; i < 26; i++){
		dict[i] = malloc(sizeof(struct linkedDict));
		dict[i]->name = malloc(sizeof(char));
		*(dict[i]->name) = (char)(i+65);
		dict[i]->root = NULL;
		dict[i]->size = 0;
	}

	return dict;
}

struct dictNode *insertNode(struct dictNode *tobeInserted, struct linkedDict *dict){
	/*!The function takes the precreated node that is going to be inserted to the tree,
	 * also the correct tree in the linked list, which needs to be generated by another function
	 * The function returns the new root of the AVL tree or no return but update the root of the tree directly
	 */

	//if the inserting node is empty
	//struct dictNode* r = malloc(sizeof(struct dictNode));
	if (tobeInserted == NULL){
		return NULL;
	}

	//if the inserting node is not empty
	else{
		//check if the dictionary is empty
		if(dict->root == NULL){
			dict->root = tobeInserted;
		}

		else{
			//check word ascii value
			if(strcmp((tobeInserted->word), (dict->root->word)) < 0){
				dict->root->leftChild = insert(tobeInserted, dict->root->leftChild);
			}
			else if(strcmp((tobeInserted->word), (dict->root->word)) > 0){
				dict->root->rightChild =  insert(tobeInserted, dict->root->rightChild);
			}

			//This is can be written as a separate function void append(struct dictNode *tobeInserted, sturct dictNode *subroot)
			//if the word already exists in the dict
			else if(strcmp((tobeInserted->word), (dict->root->word)) == 0){
				//static char *start = dict->root->def;
				//int originaldef = sizeof(dict->root->def); //original def size, unsure to use strlen or sizeof
				//dict->root->def = realloc(dict->root->def, (originaldef + sizeof(tobeInserted->def)) * sizeof(char));//sizeof or strlen?
				//dict->root->def = dict->root->def + originaldef;
				strcat(dict->root->def, tobeInserted->def); //update def
				//free(tobeInserted);//no need to assign a value if the function is changed to void
			}
			dict->root = balanceTree(dict->root, tobeInserted);
		}
	}
	dict->size = dict->size + 1;
	//r = dict->root;
//	printf("it returned: %s\n", dict->root->word);
	return dict->root;
}


struct dictNode *deleteNode(struct dictNode *tobeDeleted, struct linkedDict *dict){
	/*! Frees memory used by the node toBeDeleted
	 * Returns the new root after deletion
	 */
	if(tobeDeleted == NULL){
		return NULL;
	}

	else{
		//check if the dictionary is empty
		if(dict->root == NULL){
			dict->root = NULL;
		}

		else{
			//check word ascii value
			if(strcmp((tobeDeleted->word), (dict->root->word)) < 0){
				dict->root->leftChild = delete(tobeDeleted, dict->root->leftChild);
			}
			else if(strcmp((tobeDeleted->word), (dict->root->word)) > 0){
				dict->root->rightChild =  delete(tobeDeleted, dict->root->rightChild);
			}
			else{
				//one child case
				if((dict->root->leftChild == NULL) || (dict->root->rightChild == NULL)){
				   struct dictNode *temp = dict->root->leftChild ? dict->root->leftChild : dict->root->rightChild;

					// No child case
					if (temp == NULL)
					{
						temp = dict->root;
						dict->root = NULL;
					}
					else // One child case
					 *(dict->root) = *temp; // Copy the contents of
									// the non-empty child
					free(temp);
				}
				//two child case
				else{
					// Get the inorder successor (smallest in the right subtree)
//					printf("root right: %s\n", dict->root->rightChild->word);

//					printf("here\n");
					struct dictNode* temp = minValueNode(dict->root->rightChild);
					struct dictNode* leftbranch = dict->root->leftChild;
					struct dictNode* rightbranch = dict->root->rightChild;
//					printf("root right: %s\n", dict->root->rightChild->word);

					// Copy the inorder successor's data to this node
					*(dict->root) = *temp;

					//retain its original leftbranch
					dict->root->leftChild = leftbranch;
					dict->root->rightChild = rightbranch;

					// Delete the inorder successor
					dict->root->rightChild = delete(dict->root->rightChild, temp);

//					printf("out?");
					free(leftbranch);
					//free(temp); not sure whether to free it here
				}
			}
		}
	}

	dict->size = dict->size - 1;
	return dict->root;
}


int findDict(struct dictNode* target){
	//need to convert all word to uppercase when making the node
	return toupper(target->word[0]) - 65;
}

int getSize(struct linkedDict* dict){
	return dict->size;
}

char* getAuthor(struct linkedDict* dict){
	return dict->author;
}

char* getDef(struct dictNode* target, struct linkedDict** dict){
	int c = findDict(target);

	if(strcmp(target->word, dict[c]->root->word) == 0){
		return dict[c]->root->def;
	}
	else if(strcmp(target->word, dict[c]->root->word) < 0){
		return getDef_Helper(target, dict[c]->root->leftChild);
	}
	else if(strcmp(target->word, dict[c]->root->word) > 0){
		return getDef_Helper(target, dict[c]->root->rightChild);
	}

//	printf("%s not found in dict.\n", target->word);
	return NULL;
}

char* getDef_Helper(struct dictNode* target, struct dictNode* subroot){
	if(strcmp(target->word, subroot->word) == 0){
		return subroot->def;
	}
	else if(strcmp(target->word, subroot->word) < 0){
		return getDef_Helper(target, subroot->leftChild);
	}
	else if(strcmp(target->word, subroot->word) > 0){
		return getDef_Helper(target, subroot->rightChild);
	}

//	printf("%s not found in dict.\n", target->word);
	return NULL;
}

int levenshtein(const char *strA, int lenA, const char *strB, int lenB){
	int a, b, c;

	//If strings are empty, distance is num of characters of the other
	if (!lenA) return lenB;
	if (!lenB) return lenA;

	//If last letters are the same, the difference is whatever is required to edit the rest of the strings
	if (strA[lenA - 1] == strB[lenB - 1]) return levenshtein(strA, lenA - 1, strB, lenB - 1);

	/*If last letters are not the same, try:
	 *	changing last letter of s to that of t; or
	 *  remove last letter of s; or
	 *  remove last letter of t,
	 * any of which is 1 edit plus editing the rest of the strings
	 */
	a = levenshtein(strA, lenA - 1, strB, lenB - 1);
	b = levenshtein(strA, lenA, strB, lenB - 1);
	c = levenshtein(strA, lenA - 1, strB, lenB);

	if (a > b) a = b;
	if (a > c) a = c;

	return a + 1;
}

/*
struct linkedDict* loadTree_fromFile(char* filename){
	FILE *fptr = fopen(filename, "r");

	fclose(fptr);
}*/

char* scroll(struct linkedDict* dict, char* target, char* direction){
	struct dictNode *node = returnNode(dict->root, target);

	if(strcmp(direction, "up") == 0) return node->previousWord->word;
	else if(strcmp(direction, "down") == 0) return node->nextWord->word;
	return target;
}

void dummyLoad(struct linkedDict **dict){
	char w[] = "Trist\0";
	char d[] = "Robitaille\0";
	struct dictNode *n = createNode(w,d);
	n->previousWord = NULL;

	//create node terry
	char w2[] = "Terry\0";
	char d2[] = "Wu\0";
	struct dictNode *m = createNode(w2, d2);
	m->previousWord = n;
	n->nextWord = m;

	//create node tina
	char w3[] = "Treee\0";
	char d3[] = "Zhang\0";
	struct dictNode *k = createNode(w3, d3);
	k->previousWord = m;
	m->nextWord = k;

	//create node tina
	char w4[] = "Treas\0";
	char d4[] = "Zhang\0";
	struct dictNode *l = createNode(w4, d4);
	l->previousWord = k;
	k->nextWord = l;

	//create node tina
	char w5[] = "Troph\0";
	char d5[] = "Zhang\0";
	struct dictNode *p = createNode(w5, d5);
	p->previousWord = l;
	l->nextWord = p;

	p->nextWord = NULL;

	//find tree index
	int c = findDict(n);

	//insert nodes
	dict[c]->root = insertNode(n, dict[c]);
	dict[c]->root = insertNode(m, dict[c]);
	dict[c]->root = insertNode(k, dict[c]);
	dict[c]->root = insertNode(l, dict[c]);
	dict[c]->root = insertNode(p, dict[c]);
}

